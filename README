


ΟΔΗΓΙΕΣ ΜΕΤΑΓΛΩΤΙΣΣΗΣ :　make t1. Για την εκτέλεση αρκεί η εντολή που περιγράφεται στην εκφώνηση.

Ο ΦΑΚΕΛΟΣ seitutsi είναι απαραίτητος για τη δημιουργία pipes.


Η εργασία υλοποιήθηκε σε περιβάλλον UBUNTU 16.04 LTS

Λειτουργεί κατά το μεγαλύτερό της μέρος, εκτός από την παράμετρο deadline στη search και την "κλωνοποίηση" παιδιού σε περίπτωση σήματος SIGKILL από το χρήστη.

Το main πρόγραμμα διαβάζει και αποθηκεύει τους καταλόγους που περιέχει το docfile και υπολογίζει τον αριθμό τους. Καλεί τη server_j η οποία στην ουσία είναι η κύρια συνάρτηση της εργασίας και κάνει τον απαιτούμενο αριθμό fork, μοιράζει στα παιδιά τους καταλόγους που πρέπει να πάρουν (επικοινώντας με αυτά μέσω named pipes). Το πρωτόκολλο ονομασίας των σωλήνων που επέξα είναι απλώς μια μοναδιαία αύξηση του τελικού χαρακτήρα του ονόματος του προηγουμένου και υπάρχουν 2 για κάθε παιδί : ένα να διαβάζει και σε ένα να γράφει.

Αφού τελειώσει ο διαμοιρασμός καταλόγων στα παιδιά (με το απλούστερο δυνατό loadbalancing δηλαδή αριθμός καταλογων/παιδια και το υπολοιπο να μοιραζεται απο ενα τη φορα) περνάμε στο μενού επιλογών του χρήστη στο οποίο δίνονται οι εντολές. Να σημειωθεί ότι για την οργάνωση δεδομένων στο παιδί επέλεξα το trie που είχα υλοποιήσει στην 1η εργασία για μεγαλύτερη αποδοτικότητα στην αναζήτηση και χειρισμό δεδομένων.

Στο τέλος, κατά την εντολή exit, ο πατέρας στέλνει αντίστοιχο μήνυμα στα παιδιά, τα οποία και αποδεσμεύουν τις δομές που είχαν χρησιμοποιήσει και τελικά επιστρέφουν 0. Υπάρχει μια global μεταβλητή που ενημερώνουν ώστε να μην εκτελεστεί κώδικας της main που δεν πρέπει από τα παιδιά.



https://stackoverflow.com/questions/31057175/reading-text-file-of-unknown-size 
είναι το λινκ το οποίο βρήκα για το πώς να πάρω σωστά το input από κείμενο αγνώστου μήκους.
Στο bash script θα βρείτε άλλο ενα λινκ που αφορά τη λειτουργία αυτού (του bash script).
